3) Run the following commands
a. sudo su
b. apt update 
4) Setup Docker ,Terraform ,aws cli , and Kubectl
apt install docker.io

2. usermod -aG docker $USER # Replace with your username e.g ‘ubuntu’  usermod -aG docker ubuntu
   3. newgrp docker

5) We will now setup terraform in the machine 
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
6) Now we will setup the AWS CL
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
apt install unzip -y
unzip awscliv2.zip
sudo ./aws/install
7) Now we will setup Kubectl 
sudo apt install curl -y
curl -LO https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl



8) Every thing is setup and installed let’s make a IAM EC2 Role
Go to IAM -> Roles

click on create role and choose EC2 from the dropdown


Choose administrator access 



Next


Click on Create role



9) Now we will attach the IAM role to Ec2 machine
Go to ec2 machine and select the machine 


Right click on the machine 

Click on Security -> modify IAM role




Select IAM role which we created previously 


Click on update IAM role

10) Building Infrastructure Using terraform
First we will clone the github repo 
 Go to the machine 
mkdir supermario
cd supermario


git clone https://github.com/akshu20791/supermario-game






cd supermario-game


cd EKS-TF


12) Go to aws -> S3 -> Create a s3 bucket with some unique name






Create bucket 
13) Go back to Ec2 machine 
edit the backend.tf file by → vim backend.tf



Note →make sure to provide your bucket and region name in this file otherwise it doesn’t work and IAM role is also associated with your ec2 which helps ec2 to use other services such S3 bucket


14) Now we will run 
vim main.tf
############################
# EKS CLUSTER IAM ROLE
############################
 
data "aws_iam_policy_document" "eks_cluster_assume_role" {
  statement {
    effect = "Allow"
 
    principals {
      type        = "Service"
      identifiers = ["eks.amazonaws.com"]
    }
 
    actions = ["sts:AssumeRole"]
  }
}
 
resource "aws_iam_role" "eks_cluster_role" {
  name               = "eks-cluster-role"
  assume_role_policy = data.aws_iam_policy_document.eks_cluster_assume_role.json
}
 
resource "aws_iam_role_policy_attachment" "eks_cluster_policy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  role       = aws_iam_role.eks_cluster_role.name
}
 
############################
# WORKER NODE IAM ROLE
############################
 
data "aws_iam_policy_document" "eks_node_assume_role" {
  statement {
    effect = "Allow"
 
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
 
    actions = ["sts:AssumeRole"]
  }
}
 
resource "aws_iam_role" "eks_node_role" {
  name               = "eks-node-role"
  assume_role_policy = data.aws_iam_policy_document.eks_node_assume_role.json
}
 
resource "aws_iam_role_policy_attachment" "worker_node_policy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
  role       = aws_iam_role.eks_node_role.name
}
 
resource "aws_iam_role_policy_attachment" "cni_policy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
  role       = aws_iam_role.eks_node_role.name
}
 
resource "aws_iam_role_policy_attachment" "ecr_policy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
  role       = aws_iam_role.eks_node_role.name
}
 
############################
# DEFAULT VPC & SUBNETS
############################
 
data "aws_vpc" "default" {
  default = true
}
 
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}
 
############################
# EKS CLUSTER
############################
 
resource "aws_eks_cluster" "eks_cluster" {
  name     = "hemanth_cluster"
  role_arn = aws_iam_role.eks_cluster_role.arn
 
  vpc_config {
    subnet_ids = data.aws_subnets.default.ids
  }
 
  depends_on = [
    aws_iam_role_policy_attachment.eks_cluster_policy
  ]
}
 
############################
# NODE GROUP
############################
 
resource "aws_eks_node_group" "eks_nodes" {
  cluster_name    = aws_eks_cluster.eks_cluster.name
  node_group_name = "my-node-group"
  node_role_arn   = aws_iam_role.eks_node_role.arn
  subnet_ids      = data.aws_subnets.default.ids
 
  scaling_config {
    desired_size = 2
    max_size     = 3
    min_size     = 1
  }
 
  instance_types = ["t3.medium"]
 
  depends_on = [
    aws_iam_role_policy_attachment.worker_node_policy,
    aws_iam_role_policy_attachment.cni_policy,
    aws_iam_role_policy_attachment.ecr_policy
  ]
}

terraform init




terraform validate


## go to AWS ACCOUNT -> GO TO VPC -> GO TO SUBNETS -> DELETE subnet in availability zone us-east-1e





terraform plan 





terraform apply --auto-approve



It will take 10-15 minutes to complete 


15) Now we will update the configuration of EKS 
aws eks update-kubeconfig --name hemanth_cluster --region us-east-1
# ensure that you take care of the region you are working in 




16) Creation of deployment and service for EKS
change the directory where deployment and service files are stored use the command → cd ..

create the deployment
    kubectl apply -f deployment.yaml


               kubectl apply -f service.yaml




run → kubectl get all



16) Now Run the follwing command to get the load balancer ingress
This command tells all the details of your application
kubectl describe service mario-service

Here you will see load balancer ingress link 
Copy that 


17) paste it in the browser 
Ensure that when you copy paste …it should be http not https



